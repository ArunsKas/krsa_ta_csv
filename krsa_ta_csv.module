<?php

global $url_base;
$url_base = 'https://www.kretinga.lt';

function krsa_ta_csv_menu() {
  $items = array();
  $items['ta_csv'] = array(
    'title' => 'TA to CSV',
    'page callback' => 'krsa_ta_csv',
    'access arguments' => array(true),
    'type' => MENU_NORMAL_ITEM,
  );
  $items['ta_csv/delete/%'] = array(
    'page callback' => '_krsa_ta_csv_delete',
    'access arguments' => array(true),
    'page arguments' => array(2),
    'type' => MENU_CALLBACK,
  );
  $items['ta_csv/scrap/update_t2'] = array(
    'page callback' => '_krsa_scrap_again_t2',
    'access arguments' => array(true),
    'type' => MENU_CALLBACK,
  );
  $items['ta_csv/parce_last_csv'] = array(
    'page callback' => '_parse_all_ta_info2',
    'access arguments' => array(true),
    'type' => MENU_CALLBACK,
  );
  return $items;
}

function krsa_ta_csv() {
  
  $scrap_link = l(t('Scrap again'), 'ta_csv/scrap/update_t2');
  
  $parce_link = l(t('Parse last scraped csv'), 'ta_csv/parce_last_csv');
    
  //_parse_all_ta_info2();
  
  return $scrap_link . ' <br />' . $parce_link . ' ' . _csv_files_table();
}

/**
 * scrap pages and write data to csv
 * 
 */
function _krsa_scrap_again_t2() {
  global $url_base;
  $referer = referer_path();
  $url_of_all_tarspr = 'https://www.kretinga.lt/node/251';
  $html_obj = file_get_html($url_of_all_tarspr);
  $node_html_obj = $html_obj->getElementById("node-251");

  $links = array();
  foreach ($node_html_obj->find('li.leaf a') as $link) {
    $url = $url_base . $link->href;
    $links[] = $url;
    $all_ta_info[] = _get_ta_rows_content($url);
  }

  // Release resources to avoid memory leak in some versions.
  $html_obj->clear();
  unset($html_obj);

  $parsed_data = _parse_all_ta_info($all_ta_info);
  _write_to_csv($parsed_data);
  drupal_goto($referer);
}

/**
 * Get HTTP_REFERER as Drupal normal path without language prefix.
 */
function referer_path() {
  if (!empty($_SERVER['HTTP_REFERER'])) {
    $url = parse_url($_SERVER['HTTP_REFERER']);
    if ($url['path'][0] == '/') {
      $url['path'] = substr($url['path'], 1);
    }
    //list(, $path) = language_url_split_prefix($url['path'], language_list());
    return $url['path'];
  }
}

function _krsa_ta_csv_delete($fid) {
  $referer = referer_path();
  $file = file_load($fid);
  file_delete($file);
  drupal_goto($referer);
}

function _parse_all_ta_info2() {
  $referer = referer_path();
  $public_path = variable_get('file_public_path', conf_path());
  $path = $public_path . '/csv';
  $mask = '/^t2-scrap.*.csv$/';
  $csv_files = file_scan_directory($path, $mask);  
  
  $files_objects_arr = array();
  foreach ($csv_files as $file) {
    $uri = 'public://' . ltrim($file->uri, $public_path);
    if ($file_obj = _file_load_by_uri($uri)) {
      $files_objects_arr[] = $file_obj;
    }
  }

  // sort by last update time
  uasort($files_objects_arr, '__sort_callback');
  
  $newest_csv_uri = array_values($files_objects_arr)[0]->uri;
  
  // load csv file and parse data to one line per doc with attachments
  $csv_uri = $newest_csv_uri;
  $handle = fopen($csv_uri, 'r');
  $row = fgetcsv($handle);
  $columns = array();
  foreach ($row as $i => $header) {
    $columns[$i] = strtolower(trim($header));
  }
  $csv_rows = array();
  while ($row = fgetcsv($handle)) {
    $csv_row = array();
    foreach ($row as $i => $field) {
      $csv_row[$columns[$i]] = $field;
    }
    $csv_rows[] = $csv_row;
  }

  $result = array();
  $attached_doc = array();
  foreach($csv_rows as $key => $row) {
    $title = $row['title'];
    if (_similar_to_main_doc($title)) {
      // if new main doc started then first write previous doc with attach to 
      // array
      if (isset($main_doc)) {
        _parse_all_ta_info2_write($main_doc, $attached_doc, $result);
      }
      $main_doc = $row;
      $attached_doc = array();
    } else {
      // clear attachment title text
      $attached_doc[] = array(
        'title' => _clear_text_string($row['title']),
        'link' => $row['link']
          );
    }    
  }
  _parse_all_ta_info2_write($main_doc, $attached_doc, $result);
  _write_parsed_to_csv($result);
  drupal_goto($referer);
}

function _write_parsed_to_csv($data) {
  
  // prepare data for writing to csv
  // calculate max attachment amount for header line formatting
  $count = 0;
  $max_attach_amount = 0;
  foreach($data as $key => $row) {
    if ($row['attach']) {
      if (count($row['attach']) > $max_attach_amount) {
        $max_attach_amount = count($row['attach']);
      }
      $count++;
    }
  }
  
  // prepare header line
  $csv_header = array(
    'DocNo',
    'DocDate',
    'DocTitle',
    'DocLink',
  );
  for ($i = 1; $i <= $max_attach_amount; $i++) {
    array_push($csv_header, ('Attach' . $i));
    array_push($csv_header, ('Link' . $i));
  }
  
  // prepare other lines
  $prepared_lines = array();
  $prepared_row = array();
  foreach($data as $i => $row) {
    $prepared_row = array(
      $row['no'],
      $row['docdate'],
      $row['title'],
      $row['main']['link'],
    );
    for ($i = 0; $i < $max_attach_amount; $i++) {
      if ($row['attach'] && (isset($row['attach'][$i]))) {
        array_push($prepared_row, $row['attach'][$i]['title']);
        array_push($prepared_row, $row['attach'][$i]['link']);
      }
    }
    $prepared_lines[] = $prepared_row;
  }
  
  
  // write data to csv
  $path = 'public://csv/';
  $filename = 't2-parsed-output.csv';
  // Ensure the directory
  if (!file_prepare_directory($path, FILE_CREATE_DIRECTORY)) {
    drupal_set_message(t('Unable to create directory in file system. Check permissions and try again.'), 'error');
    return;
  }
  // Ensure the file
  $file = file_save_data('', $path . $filename);
  if (!$file) {
    drupal_set_message(t('Unable to write to file system. Check permissions and try again.'), 'error');
    return;
  }
  // Stream data - This is a simplified example. Better to do it in a batch if you have a high volume of data
  $fh = fopen($file->uri, 'w');
  if (!$fh) {
    drupal_set_message(t('Unable open file for writing. Check permissions and try again.'), 'error');
    return;
  }
  
  // write header line to csv file
  fputcsv($fh, $csv_header);

  // write other lines to csv file
  foreach ($prepared_lines as $prepared_line) {
    fputcsv($fh, $prepared_line);
  }

  fclose($fh);
  
  // Notify the filesystem of the size change
  $file->filesize = filesize($file->uri);
  file_save($file);
  
  // Tell the user where we stuck it
  drupal_set_message( t('New csv file: <a href="!url">!filename</a>.', array(
    '!url' => file_create_url($file->uri),
    '!filename' => $filename,
  )));
}

function _csv_files_table() {
  $public_path = variable_get('file_public_path', conf_path());
  $path = $public_path . '/csv';
  $mask = '/\.csv$/';
  $csv_files = file_scan_directory($path, $mask);  
  
  $header = array(
    array('data' => t('Filename')),
    array('data' => t('Filesize')),
    array('data' => t('Last Update')),
    array('data' => t('Operations'))
  );
  
  $rows = array();
  
  $files_objects_arr = array();
  foreach($csv_files as $file) {
    $uri = 'public://' . ltrim($file->uri, $public_path);
    if ($file_obj = _file_load_by_uri($uri)) {     
      $files_objects_arr[] = $file_obj;
    }    
  }
  
  // sort by last update time
  uasort($files_objects_arr, '__sort_callback');
  
  foreach ($files_objects_arr as $file_obj) {
    $update = format_date($file_obj->timestamp, $type = 'medium');
    $filename = drupal_basename($file_obj->uri);
    $file_link = l($filename, file_create_url($file_obj->uri));
    $filesize = filesize($file_obj->uri);

    preg_match('/^t2-scrap.*.csv$/', $filename, $matches);
    if ($matches && $matches[0]) {
      $operations = l(t('delete'), 'ta_csv/delete/' . $file_obj->fid);
    }
    else {
      preg_match('/^t2-parsed.*.csv$/', $filename, $matches);
      if ($matches && $matches[0]) {
        $operations = l(t('delete'), 'ta_csv/delete/' . $file_obj->fid);
      } else {
        $operations = '';
      }
    }

    $rows[] = array(
      array('data' => $file_link),
      array('data' => $filesize),
      array('data' => $update),
      array('data' => $operations)
    );
  }

  return theme('table', array('header' => $header, 'rows' => $rows));  
}

/**
 * custom callback for php uasort function
 */
function __sort_callback($a, $b) {
  if ($a->fid == $b->fid) {
    return 0;
  }
  return ($a->fid > $b->fid) ? -1 : 1;
}

/**
 * Load file object by uri. This function is missing in drupal file api
 */
function _file_load_by_uri($uri) {
  $query = db_select('file_managed', 'fm');
  $query->condition('uri', $uri, '=');
  $query->fields('fm', array('fid'));
  $result = $query->execute()->fetchCol();
  if (!empty($result) && ($fid = $result[0])) {
    return file_load($fid);
  }
  else {
    return FALSE;
  }
}

function _parse_all_ta_info2_write($main_doc, $attached_doc, &$result) {
  $doc_no = _get_doc_no($main_doc['title']);
  $doc_y = _get_doc_year($main_doc['title']);
  $doc_d = _get_doc_day($main_doc['title']);
  $doc_m = _get_doc_month($main_doc['title'], $doc_y, $doc_d);
  $doc_title = _get_doc_title($main_doc['title'], $doc_no);

  $date_str = $doc_y . '-' . $doc_m . '-' . $doc_d;
  $timestamp = strtotime($date_str);
  // write to array only valid date format 
  $date_valid = $timestamp ? $date_str : '';

  $result[$date_valid . ' ' . $doc_no] = array(
    'no' => $doc_no,
    'docdate' => $date_valid,
    'title' => $doc_title,
    'main' => $main_doc,
    'attach' => $attached_doc);
}

function _get_doc_title($txt, $doc_no) {

  // replace tab to space
  $txt = str_replace("\t", " ", $txt);
  
  $doc_no_len = strlen($doc_no);
  $doc_no_pos = strpos($txt, $doc_no);
  $txt_len = strlen($txt);
  // cut string from start up to doc no end
  $title = substr($txt, $doc_no_pos + $doc_no_len, $txt_len);
  
  $title = _clear_text_string($title);
  
  //$title = check_plain($title);
  
  return $title;
}

function _clear_text_string($text) {
  // remove spaces from start and end
  $text = trim($text);
  // remove dot from start and end '.'
  $text = trim($text, '.');
  // decode special chars like '&quot;'
  $text = htmlspecialchars_decode($text);
  $text = decode_entities($text);
  // remove double and more spaces 
  $text = preg_replace("/ {2,}/", " ", $text);
  // remove string '(neskelbiamas)' from end
  $text = str_replace('(neskelbiamas)', '', $text);
  // remove spaces from start and end
  $text = trim($text);
  // remove start german quote
  $text = trim($text, '„');
  // remove end german quote
  $text = trim($text, '“');  
  // remove double quote '"' from start and end
  $text = trim($text, '"');
  // replace ' " ' (space double quote space) to '" '
  $text = str_replace(' " ', '" ', $text);
  // fix number of open close quotes  
  $text = _fix_quotes($text);
  return $text;
}

/**
 * fix number of open close quotes  
 * @param type $text
 * @return string
 */
function _fix_quotes($text) {
  $q1 = '"';
  $q2 = '„';
  $q3 = '“';
  $pos_q1 = strpos($text, $q1);
  if ($pos_q1) {
    // convert all quotes to q1 type if quote of q1 type found in string
    $text = str_replace($q2, $q1, $text);
    $text = str_replace($q3, $q1, $text);
    $count_q1 = substr_count($text, $q1);
    if ($count_q1 % 2 <> 0) {
      // append q1 to end of string
      $text = $text . $q1;
    } else {
      // check requirement and add missing quote at end if needed
      $open_q1_count = substr_count($text, ' "');
      $total_q1_count = substr_count($text, '"');
      if ($total_q1_count - $open_q1_count < $open_q1_count) {
        $text = $text . $q1;
      }
    }
    
    // replace all ' "' to opening quote
    $text = str_replace(' "', ' '.$q2, $text);
    // replace all '" ' to closing quote
    $text = str_replace('" ', $q3. ' ', $text);
    
    // replace all '"' at string end to closing quote
    $last_char = substr($text, -1);
    if ($last_char == '"') {
      $text = substr($text, 0, -1).$q3;  
    }
  } else {
    $count_q2 = substr_count($text, $q2);
    $count_q3 = substr_count($text, $q3);
    if ($count_q2 - $count_q3 == 1) {
      // append missing q3
      $text = $text . $q3;
    }
  }
  
//  $space_q1_pos = strpos($text, ' "');
//  $space_q1_count = substr_count($text, ' "');
//  $quote_count = substr_count($text, '"');
//  if (($space_q1_count >= 2) ) {
//    dd($space_q1_count. ' ' . $text);
//    dd($text);
//  }
  
//  $pattern = '/([\s\\"]{1,})/';
//  preg_match_all($pattern, $text, $matches);
//  if (!empty($matches) && isset($matches[0])) {
//    kpr($matches);
//  }
  
  return $text;
}

function _get_doc_month($txt, $y, $d) {
  // cut first year four digits from text 
  $txt_without_y = substr($txt, strpos($txt, $y) + 4, strlen($txt));
  // cut text after two day digits
  $day_pos = strpos($txt_without_y, ltrim($d, '0'));
  $txt1 = substr($txt_without_y, 0, $day_pos);
  $txt2 = trim(ltrim(trim(str_replace($y, '', $txt1)), 'm.'));

  switch ($txt2) {
    case 'sausio':
      $result = '01';
      break;
    case 'vasario':
      $result = '02';
      break;
    case 'kovo':
      $result = '03';
      break;
    case 'balandžio':
      $result = '04';
      break;
    case 'gegužės':
      $result = '05';
      break;
    case 'birželio':
      $result = '06';
      break;
    case 'liepos':
      $result = '07';
      break;
    case 'rugpjūčio':
      $result = '08';
      break;
    case 'rugsėjo':
      $result = '09';
      break;
    case 'spalio':
      $result = '10';
      break;
    case 'lapkričio':
      $result = '11';
      break;
    case 'gruodžio':
      $result = '12';
      break;
    default:
      $result = '';
      break;
  }
  return $result;
}

function _get_doc_day($txt) {
  $pattern = '/(\s|[a-z]*)\b([0-9]{1,2})\b/';
  preg_match_all($pattern, $txt, $matches);
  return str_pad(trim($matches[0][0]), 2, "0", STR_PAD_LEFT);
}

/**
 * function to return first match of dddd (four digit year)
 * @param type $txt
 * @return type
 */
function _get_doc_year($txt) {
  $pattern = '/([0-9]{4})/';
  preg_match_all($pattern, $txt, $matches);
  return $matches[0][0];
}

/**
 * function to return first match of T2-ddd
 * @param type $txt
 * @return type
 */
function _get_doc_no($txt) {
  $pattern = '/\T2-([0-9]*)/';
  preg_match_all($pattern, $txt, $matches);
  return $matches[0][0];
}

function _similar_to_main_doc($title) {
  $needle = 'tarybos sprendimas';
  $title_low = strtolower($title);
  $pos = strpos($title_low, $needle);
  if (($pos > 10) && ($pos < 30)) {
    return true;
  } 
  return false;
}

function _write_to_csv($data) {
  $path = 'public://csv/';
  $filename = 't2-scrap-output.csv';
  // Ensure the directory
  if(!file_prepare_directory($path, FILE_CREATE_DIRECTORY)){
    drupal_set_message( t('Unable to create directory in file system. Check permissions and try again.'), 'error' );
    return;
  }
  // Ensure the file
  $file = file_save_data('', $path . $filename);
  if(!$file){
    drupal_set_message( t('Unable to write to file system. Check permissions and try again.'), 'error' );
    return;
  }
  // Stream data - This is a simplified example. Better to do it in a batch if you have a high volume of data
  $fh = fopen($file->uri, 'w');
  if(!$fh){
    drupal_set_message( t('Unable open file for writing. Check permissions and try again.'), 'error' );
    return;
  }
  
  fputcsv($fh, array(
    'Title',
    'Link',
  ));
  
  foreach ($data as $month_group_items) {
    foreach ($month_group_items as $item) {
      fputcsv($fh, array(
      $item['title'],
      $item['href'],
    ));
    }
  }
  fclose($fh);
  
  // Notify the filesystem of the size change
  $file->filesize = filesize($file->uri);
  file_save($file);
  // Tell the user where we stuck it
  drupal_set_message( t('New csv file: <a href="!url">!filename</a>.', array(
    '!url' => file_create_url($file->uri),
    '!filename' => $filename,
  )));
}

/**
 * Function parse raw array data from scraper to strict structure:
 * - new row per month / scrapped page
 * - each sub row can be main document or extra document (attachment to main doc)
 * - each document can have link to file or link can be empty
 * - each document must have title
 * @param array $all_ta_info - multidimensional array of scrapped tables rows
 * @return array - multidimensional parsed structured array
 */
function _parse_all_ta_info($all_ta_info) {

  $parsed_data = array();
  foreach($all_ta_info as $key => $ta_per_month) {
    $count_a = count($ta_per_month['a']);
    $count_p = count($ta_per_month['p']);
    
    $ta_per_month_result = $ta_per_month['a'];
    if ($count_p > $count_a) {
      // if some records don't have links to file
      
      $tmp_a = array();
      foreach ($ta_per_month['a'] as $item_a) {
        $tmp_a[] = $item_a['title'];
      }
      
      // create array with records without links
      $arr1 = $ta_per_month['p'];
      $arr2 = $tmp_a;
      $without_links_arr = _array_diff_by_str_val($arr1, $arr2);
      
      // insert records without links in array whose records are only with links
      foreach ($without_links_arr as $index => $value) {
        array_splice($ta_per_month_result, $index, 0, array($value));
      }
    } else {
      // all records have links - nothing to do.      
    }
    $parsed_data[$key] = $ta_per_month_result;
  }
  return $parsed_data;
}

// create array with records without links
// similar to array_diff()
function _array_diff_by_str_val($arr1, $arr2) {
  $pos_shift = 0;
  $array_diff = array();
  foreach ($arr1 as $pos => $item) {
    if (isset($arr2[$pos + $pos_shift])) {
      if (!($item == $arr2[$pos + $pos_shift])) {
        $array_diff[$pos] = array('title' => $item, 'href' => '');
        $pos_shift--;
      }
    }
    else {
      $array_diff[$pos] = array('title' => $item, 'href' => '');
    }
  }
  return $array_diff;
}

// get documents list from one page (T2 case one page = one months)
// table rows are splitted by <a> and <p> tags and recorded to array fiels
function _get_ta_rows_content($url) {
  $html_obj_ta_page = file_get_html($url);
  $node_html_obj_ta = $html_obj_ta_page->getElementById("main-inner");
  
  $table_rows_a = $node_html_obj_ta->find('table.spr tr.tablerow a');
  
  global $url_base;
  $rows = array();
  foreach($table_rows_a as $row) {
    $title = trim(str_replace('&nbsp;', ' ', $row->plaintext));
    $link = $row->href;
    if (strlen($link) > 0) {
      $link = $url_base . $link;
    } 
    $rows[] = array('title' => $title, 'href' => $link);
  }
  
  $table_rows_p = $node_html_obj_ta->find('table.spr tr.tablerow p');
  
  $rows_p = array();
  foreach($table_rows_p as $row) {
    $title = trim(str_replace('&nbsp;', ' ', $row->plaintext)); //->find('tr');
    $rows_p[] = $title;
  }
  
  $html_obj_ta_page->clear();
  unset($html_obj_ta_page);
  
  return array('a' => $rows, 'p' => $rows_p);
}